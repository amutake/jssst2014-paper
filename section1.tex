\section{はじめに}

アクターモデル\cite{Agha:1986aa}は並行計算のモデルのひとつであり，互いに非同期メッセージをやりとりするアクターと呼ばれる計算主体(computing entity)によって計算システムを表現する．
現在，アクターモデルやその発展形である並行オブジェクト計算モデル\cite{Yonezawa:1986aa}にもとづく言語は多数提案・実装されてきており，それらの研究成果をもとに現在 Scala や Erlang, Akka 等，アクターモデルを並行計算の基盤としたプログラミング言語やライブラリが実用に供されている．
そのため，アクターモデルによって構成されたシステムの形式的検証は喫緊の課題であると考えられる．

形式的検証の研究に先立ち，アクターモデルの形式的意味論については古くから研究が行なわれてきた．
例えばClingerによるPowerdomainを用いた表示的意味\cite{Clinger:1981aa}や，Aghaによる操作的意味\cite{Agha:1986aa}とその発展\cite{Agha:1997aa}がある．
これらの研究では，公平性やいくつかの等価性についての成果があるものの，プロセス代数を元に発展してきた$\pi$計算等に比べると発展途上であると言わざるを得ない．

一方，形式的検証についてはアクターで記述されたシステムのモデル検査を可能にする
モデル記述言語Rebeca\cite{Sirjani:2011aa}，証明支援系を含むプログラミング言語Athenaを用いた検証例\cite{Musser:2013aa}，およびCoqを用いたアクターモデルの定式化と検証例\cite{Garnock-Jones:2014aa}など，最近になっていくつかの研究成果が出ている．
本研究はアクターで構成されたシステムのCoqによる形式的検証のための枠組みを提供することを目的としている．

アクターモデルのもつ性質には，アクターの名前は一意であるという性質(名前の一意性)，メッセージとして送られてきた名前でアクターを作ることはできないという性質(名前の新鮮性)，アクターにはいつでもメッセージを送ることができるという性質(アクターの永続性)が含まれる．
これらの性質をみたす項を構成するよう\(\pi\)計算に型システムを導入し，アクターモデルを形式化したA\(\pi\)計算がAghaらによって提案されている\cite{Agha:2004aa}．

\api の型システムにおける健全性とは，型付けされた項はアクターモデルとしての振る舞いを示すということであるが，その証明は形式的に与えられていない．
本研究では，A\(\pi\)計算およびその型システムの定義を見直すことで，型システムの健全性について定理証明支援系Coqを用いた形式的な証明を与える．また，本研究はA\(\pi\)計算自体の正しさの検証ということも目的としているため，A\(\pi\)計算の定義は等価なものへの変更でない限り変更しないものとする．
%% このようなアクターモデルの性質を満たすように設計された，$\pi$ 計算を用いた形式化として，\api が 提案されている[3] ．
%% Aπ計算は，π計算に型を付けることによってアクターモデルの性質を表現することを目的としており，may-testingと呼ばれる，二つのアクターの等価性についての理論に使われている．
%% このような基礎的な理論には形式的な証明があることが望ましい．
%% しかし，Aπ計算の性質に対して形 式的な証明を与えているものはまだない．

%% 本研究では，Aπ計算の型付けにおける健全性に対して，形式的な証明を与えることを目的とする．
%% 形式的な証明を与えるためのツールとして定理証明支援系Coqを用いる．
%% また，Coqで証明する際に，Aπ計算およびその型システムについての定義をより具体的なものに定義しなおすことによって，より簡単に証明を行えるようにしている．



%%  $ \pi $ 計算やアクターモデルは並行計算のモデルとして発展してきた．アクターモデルはアクターと呼ばれる計算主体 (computing entity) が並列に動作し，互いに非同期にメッセージを送り合うことによって計算を行う．
%% アクターモデルの持つべき性質として，アクターの名前は一意であるという性質，メッセージとして送られてきた名前でアクターを作ることはできないという性質，アクターにはいつでもメッセージを送ることができるという性質，を持っている．

%% このようなアクターモデルの性質を満たすように設計された，$\pi$ 計算を用いた形式化として，\api が提案されている\cite[Dean2008]{Agha:2004aa} ．\api は，$\pi$ 計算に型を付けることによってアクターモデルの性質を表現することを目的としており，May Testing と呼ばれる，二つのアクターの等価性についての理論に使われている．


%% このような基礎的な理論には形式的な証明があることが望ましい．しかし，\api の性質に対して形式的な証明を与えているものはまだない．


%% \subsection{目的}

%% 本研究では，\api の型付けにおける健全性に対して，形式的な証明を与えることを目的とする．
%% 形式的な証明を与えるためのツールとして定理証明支援系 Coq を用いる．
%% また，Coq で証明する際に，\api およびその型システムについての定義をより具体的なものに定義しなおすことによって，より簡単に証明を行えるようにしている．


%% \subsection{構成}

%% 第2章でアクターモデルや $\pi$ 計算，定理証明支援系 Coq などの背景知識を述べる．
%% 第3章で \api について説明し，第4章では \api およびその型付けについて定理証明支援系 Coq 上で定義し，その健全性の証明方針を述べる．第5章ではまとめとして，結論と今後の課題を述べる．


%% 自己調整二分木(スプレー木, splay tree) \cite{ST85}は，アクセスした節
%% 点に対して扁平化(splaying)操作(\ref{subsection:splaying}節)
%% を施すことにより，木の形状を動的に最適化す
%% る二分探索木の総称であり，
%% %
%% % さまざまなアク
%% % セスパターンに対して木の形状が動的に最適化してゆく二分木であり，
%% %
%% 多くの強力な性質が成り立つことがわかっている．本論文では，
%% 同一のスプレー木に対する複数の挿入削除等の操作
%% のパイプライン的並列実行を可能にする方法を検討する．目標は，下記の要請を満たす
%% 操作アルゴリズムを得ることである．
%% %
%% \begin{enumerate}
%% \item ({\bf レスポンス}) 通常のスプレー木の操作と同様，
%% 対数的な償却計算量(amortized complexity)\cite{T85}をもつ．

%% \item ({\bf スループット}) 操作後の木の形状が，根に近い部分か
%% ら葉に向かって
%% 漸増的に確定するようにすることで，個々の操作が同時に施錠しなければな
%% らない節点の数を高々${\rm O}(1)$個におさえる．
%% \end{enumerate}
%% %
%% もしスループットだけが目標ならば，二分木を用いなくても，
%% 線形リストを用いて容
%% 易に達成できる．したがって，レスポンスとスループット
%% を同時に達成することが本質的に重要である．
%% %
%% B木やその変種に対する並列操作の研究は少なくない\cite{LS86}が，スプ
%% レー木の並列性に関する研究は少なく，著者の知る限り，上記の二条件を満たす
%% 並列アルゴリズムはまだ提案されていない．

%% 本論文では，二分探索木の各節点はキーと値の対を保持するものとし，節点は
%% キーの対称順(symmetric order)に並んでいるとする．基本操作として，
%% 次の二つを考える．単なる節点値の読出しは${\it update\/}$の単純な変
%% 種と考えることができる．

%% \begin{description}
%% \item{${\it update}(i,v,v',t)$:} キー$i$をもつ節点が木$t$の中にあれば，そ
%% の節点の現在の値を$v$に代入したあと，節点に新たな値$v'$を格納する．
%% なければ，キー$i$と値$v'$をもつ節点を$t$に挿入し，$v$には節点がなかった
%% ことを示す特別の値を代入する．

%% \item{${\it delete}(i,v,t)$:} キー$i$をもつ節点が木$t$の中にあれば，その節
%% 点の現在の値を$v$に代入したあと，節点を消去する．なければ$v$に特別の
%% 値を代入する．
%% \end{description}
