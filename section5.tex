%% \section{まとめ}

%% %% 本章では，本研究の今後の課題と結論について述べる．

%% \section{課題}

%% \subsection{操作的意味論}

%% 本研究では \api の型システムを検証したが，その操作的意味論には触れていない．\api の操作的意味論は，$\pi$ 計算と同様にラベル付き遷移 (labeled transition system) を用いている．\api は，型がついているものは遷移先でも型がついているという型保存 (preservation) が成り立つ．このような\api の操作的意味論の Coq での定式化，および型保存性の証明が課題として残っている．


%% \subsection{抽出}

%% Coq は，抽出 (extraction) という機能を持っている．これは，Coq で定義した関数や証明を，対象のプログラミング言語のコードに変換する，というものである．対象のプログラミング言語は OCaml，Haskell，Scheme などがある．Coq は副作用を起こすようなコードは書くことができないので，副作用が必要な場合は他のプログラミング言語のコードに変換し，その言語の機構を用いる必要がある．

%% 本研究で定義した関数および証明を抽出し，別のプログラミング言語のコードに変換することによって，正しさが証明された \api を実装することができると考えられる．

\section{まとめと今後の課題}

本論文では，\api における型システムの定義を Coq で証明を行いやすいように再定義し，\api の型付けの健全性を形式的に証明した．
これによって \api の型システムが確かにアクターとしての振る舞いを強制することを示すための第一歩を示した．

\api の型システムが確かにアクターとしての振る舞いを強制するということを示すためには，さらに型保存性の証明が必要である．
\api の操作的意味論は $\pi$ 計算と同様にラベル付き遷移 (labeled transition system) を用いており，\api における型保存性は\api の正しく型がついた\conf は遷移を行っても正しく型がつく，というものである．
この証明がない場合は，遷移の際に型付けできないような \api の項になってしまう，つまりアクターとしての性質が成り立たないような項になる可能性が残ってしまう．
よってこの操作的意味論の Coq での形式化および型保存性の証明が課題として残っている．

また，この \api 計算の形式化をアクターの形式検証の土台として用いるためには，\api の項の性質を表すための言語内DSLを Coq 内で構築する必要がある．
この手法は $\pi$ 計算を Coq で形式化し，$\pi$ 計算の検証ライブラリとした applpi \cite{Affeldt200817} が用いており，$\pi$ 計算ベースである \api にも同様に導入できると考えられる．
